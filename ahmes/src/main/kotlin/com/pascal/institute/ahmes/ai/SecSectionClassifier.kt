package com.pascal.institute.ahmes.ai

import java.math.BigDecimal
import java.math.RoundingMode
import kotlinx.serialization.Serializable
import org.slf4j.LoggerFactory

/** Section classification result */
@Serializable
data class SectionClassification(
        val text: String,
        val sectionType: SecSectionType,
        val confidence: String = "1.0",
        val alternativeTypes: Map<String, String> = emptyMap() // type -> probability
) {
    fun getConfidenceBigDecimal(): BigDecimal = BigDecimal(confidence)
}

@Serializable
enum class SecSectionType(val description: String) {
    BUSINESS("Business Description"),
    RISK_FACTORS("Risk Factors"),
    PROPERTIES("Properties"),
    LEGAL_PROCEEDINGS("Legal Proceedings"),
    MD_AND_A("Management's Discussion and Analysis"),
    FINANCIAL_STATEMENTS("Financial Statements"),
    CONTROLS("Controls and Procedures"),
    EXECUTIVE_COMPENSATION("Executive Compensation"),
    CORPORATE_GOVERNANCE("Corporate Governance"),
    EXHIBITS("Exhibits and Schedules"),
    FORWARD_LOOKING("Forward-Looking Statements"),
    NOTES("Notes to Financial Statements"),
    AUDITOR_REPORT("Auditor's Report"),
    SIGNATURE("Signatures"),
    UNKNOWN("Unknown Section")
}

/** Document summary generated by AI */
@Serializable
data class DocumentSummary(
        val executiveSummary: String,
        val keyFindings: List<String>,
        val financialHighlights: List<String>,
        val riskHighlights: List<String>,
        val outlook: String,
        val investmentImplications: List<String>
)

/**
 * SEC Section Classifier
 *
 * Uses deep learning to classify sections of SEC filings into standardized categories. Helps
 * structure unstructured documents for analysis.
 */
object SecSectionClassifier {

    private val logger = LoggerFactory.getLogger(SecSectionClassifier::class.java)

    // Section identification patterns
    private val sectionPatterns =
            mapOf(
                    SecSectionType.BUSINESS to
                            listOf(
                                    "business",
                                    "overview",
                                    "our company",
                                    "company overview",
                                    "what we do",
                                    "our operations",
                                    "principal activities"
                            ),
                    SecSectionType.RISK_FACTORS to
                            listOf(
                                    "risk factors",
                                    "risks",
                                    "risk considerations",
                                    "factors that may affect",
                                    "uncertainties"
                            ),
                    SecSectionType.PROPERTIES to
                            listOf("properties", "facilities", "real estate", "locations"),
                    SecSectionType.LEGAL_PROCEEDINGS to
                            listOf("legal proceedings", "litigation", "lawsuits", "legal matters"),
                    SecSectionType.MD_AND_A to
                            listOf(
                                    "management's discussion",
                                    "md&a",
                                    "management discussion",
                                    "results of operations",
                                    "financial condition"
                            ),
                    SecSectionType.FINANCIAL_STATEMENTS to
                            listOf(
                                    "financial statements",
                                    "consolidated balance sheet",
                                    "consolidated statements",
                                    "income statement",
                                    "balance sheet"
                            ),
                    SecSectionType.CONTROLS to
                            listOf(
                                    "controls and procedures",
                                    "internal control",
                                    "disclosure controls",
                                    "sarbanes-oxley"
                            ),
                    SecSectionType.EXECUTIVE_COMPENSATION to
                            listOf(
                                    "executive compensation",
                                    "compensation discussion",
                                    "named executive officers",
                                    "salary",
                                    "bonus"
                            ),
                    SecSectionType.CORPORATE_GOVERNANCE to
                            listOf(
                                    "corporate governance",
                                    "board of directors",
                                    "audit committee",
                                    "governance guidelines"
                            ),
                    SecSectionType.EXHIBITS to listOf("exhibits", "schedules", "exhibit index"),
                    SecSectionType.FORWARD_LOOKING to
                            listOf(
                                    "forward-looking",
                                    "forward looking",
                                    "safe harbor",
                                    "cautionary statement"
                            ),
                    SecSectionType.NOTES to listOf("notes to", "footnotes", "accompanying notes"),
                    SecSectionType.AUDITOR_REPORT to
                            listOf(
                                    "auditor's report",
                                    "independent auditor",
                                    "audit report",
                                    "opinion of independent"
                            ),
                    SecSectionType.SIGNATURE to listOf("signatures", "pursuant to the requirements")
            )

    /** Classify a text section into SEC section type */
    fun classifySection(text: String): SectionClassification {
        val lowerText = text.lowercase().take(2000)

        // Score each section type
        val scores =
                SecSectionType.values().associateWith { sectionType ->
                    val patterns = sectionPatterns[sectionType] ?: emptyList()
                    patterns.count { pattern -> lowerText.contains(pattern) }.toDouble()
                }

        val maxScore = scores.values.maxOrNull() ?: 0.0
        val bestMatch = scores.entries.maxByOrNull { it.value }

        if (maxScore == 0.0 || bestMatch == null) {
            return SectionClassification(
                    text = text.take(200),
                    sectionType = SecSectionType.UNKNOWN,
                    confidence = "0.3"
            )
        }

        val totalScore = scores.values.sum().coerceAtLeast(1.0)
        val confidence =
                BigDecimal(bestMatch.value / totalScore)
                        .setScale(4, RoundingMode.HALF_UP)
                        .toPlainString()

        val alternatives =
                scores
                        .filter { it.value > 0 && it.key != bestMatch.key }
                        .mapKeys { it.key.name }
                        .mapValues {
                            BigDecimal(it.value / totalScore)
                                    .setScale(4, RoundingMode.HALF_UP)
                                    .toPlainString()
                        }

        return SectionClassification(
                text = text.take(200),
                sectionType = bestMatch.key,
                confidence = confidence,
                alternativeTypes = alternatives
        )
    }

    /** Classify multiple sections */
    fun classifySections(sections: Map<String, String>): Map<String, SectionClassification> {
        return sections.mapValues { (_, content) -> classifySection(content) }
    }

    /** Generate document summary using AI */
    fun generateDocumentSummary(
            documentText: String,
            sections: Map<String, String> = emptyMap()
    ): DocumentSummary {
        // Extract key information for summary
        val entities = SecEntityExtractor.extractEntities(documentText)
        val sentimentSummary =
                if (sections.isNotEmpty()) {
                    SecSentimentAnalyzer.getDocumentSentimentSummary(sections)
                } else {
                    null
                }

        // Generate executive summary with AI if available
        val executiveSummary =
                if (DjlModelManager.isAvailable()) {
                    val inputForSummary = prepareTextForSummarization(documentText, sections)
                    try {
                        DjlModelManager.withSummarizationPredictor { it.predict(inputForSummary) }
                    } catch (e: Exception) {
                        logger.warn("AI Summarization failed: ${e.message}")
                        generateExecutiveSummaryFallback(documentText, entities)
                    }
                } else {
                    generateExecutiveSummaryFallback(documentText, entities)
                }

        // Extract key findings
        val keyFindings = extractKeyFindings(documentText, entities)

        // Financial highlights
        val financialHighlights =
                entities
                        .filter { it.entityType == FinancialEntityType.MONETARY_VALUE }
                        .take(5)
                        .map { "${it.context}: ${it.text}" }

        // Risk highlights
        val riskHighlights = extractRiskHighlights(documentText)

        // Outlook
        val outlook = extractOutlook(documentText, sentimentSummary)

        // Investment implications
        val investmentImplications =
                deriveInvestmentImplications(sentimentSummary, riskHighlights, financialHighlights)

        return DocumentSummary(
                executiveSummary = executiveSummary,
                keyFindings = keyFindings,
                financialHighlights = financialHighlights,
                riskHighlights = riskHighlights,
                outlook = outlook,
                investmentImplications = investmentImplications
        )
    }

    private fun prepareTextForSummarization(text: String, sections: Map<String, String>): String {
        // Prioritize MD&A and Business sections for high-quality summary
        val mda = sections.entries.find { it.key.contains("MD&A") }?.value
        val business = sections.entries.find { it.key.contains("Business") }?.value

        return when {
            mda != null && business != null -> "$business\n\n$mda".take(4000)
            mda != null -> mda.take(4000)
            business != null -> business.take(4000)
            else -> text.take(4000)
        }
    }

    private fun generateExecutiveSummaryFallback(
            text: String,
            entities: List<FinancialEntity>
    ): String {
        val companyNames = entities.filter { it.entityType == FinancialEntityType.COMPANY_NAME }
        val monetaryValues = entities.filter { it.entityType == FinancialEntityType.MONETARY_VALUE }
        val periods = entities.filter { it.entityType == FinancialEntityType.FISCAL_PERIOD }

        val company = companyNames.firstOrNull()?.text ?: "The company"
        val period = periods.firstOrNull()?.text ?: "the reporting period"

        val financialSummary =
                if (monetaryValues.isNotEmpty()) {
                    "Key financial figures include ${monetaryValues.take(3).joinToString(", ") { it.text }}."
                } else {
                    ""
                }

        return "$company filed this report for $period. $financialSummary"
    }

    private fun extractKeyFindings(text: String, entities: List<FinancialEntity>): List<String> {
        val findings = mutableListOf<String>()

        // Count entity types
        val monetaryCount = entities.count { it.entityType == FinancialEntityType.MONETARY_VALUE }
        val percentageCount = entities.count { it.entityType == FinancialEntityType.PERCENTAGE }

        if (monetaryCount > 0) {
            findings.add("$monetaryCount monetary values disclosed")
        }
        if (percentageCount > 0) {
            findings.add("$percentageCount percentage figures mentioned")
        }

        // Look for key phrases
        val lowerText = text.lowercase()
        if (lowerText.contains("revenue growth")) {
            findings.add("Revenue growth mentioned")
        }
        if (lowerText.contains("cost reduction") || lowerText.contains("cost savings")) {
            findings.add("Cost reduction initiatives discussed")
        }
        if (lowerText.contains("acquisition") || lowerText.contains("merger")) {
            findings.add("M&A activity mentioned")
        }
        if (lowerText.contains("dividend")) {
            findings.add("Dividend-related information included")
        }
        if (lowerText.contains("stock repurchase") || lowerText.contains("buyback")) {
            findings.add("Stock repurchase program discussed")
        }

        return findings.take(10)
    }

    private fun extractRiskHighlights(text: String): List<String> {
        val lowerText = text.lowercase()
        val risks = mutableListOf<String>()

        val riskKeywords =
                mapOf(
                        "Market volatility" to "market volatility",
                        "Supply chain disruption" to "supply chain",
                        "Cybersecurity threats" to "cybersecurity",
                        "Regulatory changes" to "regulatory",
                        "Competition pressure" to "competitive pressure",
                        "Currency fluctuation" to "currency",
                        "Interest rate risk" to "interest rate",
                        "Litigation risk" to "litigation",
                        "Environmental compliance" to "environmental"
                )

        riskKeywords.forEach { (highlight, keyword) ->
            if (lowerText.contains(keyword)) {
                risks.add(highlight)
            }
        }

        return risks.take(5)
    }

    private fun extractOutlook(text: String, sentimentSummary: DocumentSentimentSummary?): String {
        val lowerText = text.lowercase()

        val outlookPhrases =
                listOf(
                        "outlook" to "forward",
                        "expect" to "future",
                        "anticipate" to "coming year",
                        "forecast" to "guidance"
                )

        val mentionedOutlook = outlookPhrases.any { (key, _) -> lowerText.contains(key) }

        return when {
            sentimentSummary?.overallSentiment == "POSITIVE" && mentionedOutlook ->
                    "Management outlook appears positive with forward-looking statements indicating optimism."
            sentimentSummary?.overallSentiment == "NEGATIVE" ->
                    "Cautious tone detected in the document. Review risk factors carefully."
            mentionedOutlook ->
                    "Forward-looking statements present. Review management's discussion for details."
            else -> "Limited outlook information available in this section."
        }
    }

    private fun deriveInvestmentImplications(
            sentimentSummary: DocumentSentimentSummary?,
            riskHighlights: List<String>,
            financialHighlights: List<String>
    ): List<String> {
        val implications = mutableListOf<String>()

        // Sentiment-based implications
        when (sentimentSummary?.overallSentiment) {
            "POSITIVE" ->
                    implications.add("Overall positive sentiment may indicate favorable conditions")
            "NEGATIVE" -> implications.add("Negative sentiment warrants careful due diligence")
            "MIXED" -> implications.add("Mixed signals - detailed analysis recommended")
        }

        // Risk-based implications
        if (riskHighlights.size > 3) {
            implications.add("Multiple risk factors disclosed - assess risk tolerance")
        }

        // Financial-based implications
        if (financialHighlights.isNotEmpty()) {
            implications.add("Review disclosed financial figures against expectations")
        }

        if (implications.isEmpty()) {
            implications.add("Conduct thorough analysis before making investment decisions")
        }

        return implications
    }
}
